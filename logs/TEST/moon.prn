MOON listing of CODE.txt.

    1     0 %DATA
    2     0 F_C_FOO1_1	dw	0
    3     4 F_P_V_f1_7	res	2100
    4  2104 F_P_V_x_8	dw	0
    5  2108 F_P_V_y_9	dw	0
    6  2112 F_P_V_i5_10	dw	0
    7  2116 F_P_V_j10_11	dw	0
    8  2120 F_P_V_ind_12	dw	0
    9  2124 V_0	dw	1
   10  2128 V_1	dw	2
   11  2132 V_2	dw	5
   12  2136 V_3	dw	5
   13  2140 V_4	dw	5
   14  2144 E_5	dw	0
   15  2148 E_6	dw	0
   16  2152 E_7	dw	0
   17  2156 V_8	dw	1
   18  2160 V_9	dw	1
   19  2164 V_10	dw	2
   20  2168 V_11	dw	2
   21  2172 E_12	dw	0
   22  2176 E_13	dw	0
   23  2180 E_14	dw	0
   24  2184 E_15	dw	0
   25  2188 E_16	dw	0
   26  2192 E_17	dw	0
   27  2196 E_18	dw	0
   28  2200 E_19	dw	0
   29  2204 E_20	dw	0
   30  2208 E_21	dw	0
   31  2212 E_22	dw	0
   32  2216 E_23	dw	0
   33  2220 E_24	dw	0
   34  2224 E_25	dw	0
   35  2228 E_26	dw	0
   36  2232 E_27	dw	0
   37  2236 E_28	dw	0
   38  2240 E_29	dw	0
   39  2244 E_30	dw	0
   40  2248 E_31	dw	0
   41  2252 E_32	dw	0
   42  2256 E_33	dw	0
   43  2260 E_34	dw	0
   44  2264 E_35	dw	0
   45  2268 E_36	dw	0
   46  2272 E_37	dw	0
   47  2276 E_38	dw	0
   48  2280 E_39	dw	0
   49  2284 E_40	dw	0
   50  2288 E_41	dw	0
   51  2292 E_42	dw	0
   52  2296 E_43	dw	0
   53  2300 E_44	dw	0
   54  2304 E_45	dw	0
   55  2308 E_46	dw	0
   56  2312 E_47	dw	0
   57  2316 E_48	dw	0
   58  2320 E_49	dw	0
   59  2324 %CODE
   60  2324 
   61  2324 		entry		%PROGRAM EXECUTION
   62  2324 		add	r14,	r0,	r0	% SET STACK POINTER
   63  2328 
   64  2328 
   65  2328 		add	r11,	r0,	r0	% RESET OFFSET
   66  2332 
   67  2332 		lw	r1,	V_0(r0)		%x = 1
   68  2336 		sw	F_P_V_x_8(r0),	r1
   69  2340 
   70  2340 		add	r11,	r0,	r0	% RESET OFFSET
   71  2344 
   72  2344 		lw	r1,	V_1(r0)		%y = 2
   73  2348 		sw	F_P_V_y_9(r0),	r1
   74  2352 
   75  2352 		add	r11,	r0,	r0	% RESET OFFSET
   76  2356 
   77  2356 		lw	r1,	V_2(r0)		%i5 = 5
   78  2360 		sw	F_P_V_i5_10(r0),	r1
   79  2364 
   80  2364 		add	r11,	r0,	r0	% RESET OFFSET
   81  2368 
   82  2368 		lw	r2,	V_3(r0)		%5+5
   83  2372 		lw	r1,	V_4(r0)		%
   84  2376 		add	r3,	r1,	r2
   85  2380 		sw	E_5(r0),	r3
   86  2384 		lw	r1,	E_5(r0)		%j10 = 5
   87  2388 		sw	F_P_V_j10_11(r0),	r1
   88  2392 
   89  2392 		add	r11,	r0,	r0	% RESET OFFSET
   90  2396 
   91  2396 		addi	r11,	r11,	0	% Class Variable Offset 0
   92  2400 
   93  2400 		subi	r14,	r14,	4	% PUSH r11
   94  2404 		sw	topaddr(r14),	r11
   95  2408 
   96  2408 
   97  2408 		add	r11,	r0,	r0	% RESET OFFSET
   98  2412 
   99  2412 
  100  2412 		lw	r11,	topaddr(r14)	%	POP r11
  101  2416 		addi	r14,	r14,	4
  102  2420 
  103  2420 
  104  2420 		subi	r14,	r14,	4	% PUSH r11
  105  2424 		sw	topaddr(r14),	r11
  106  2428 
  107  2428 
  108  2428 		add	r11,	r0,	r0	% RESET OFFSET
  109  2432 
  110  2432 
  111  2432 		lw	r11,	topaddr(r14)	%	POP r11
  112  2436 		addi	r14,	r14,	4
  113  2440 
  114  2440 		%SET ARRAY INDEX: x
  115  2440 		addi	r1,	r0,	20
  116  2444 		lw	r2,	F_P_V_x_8(r0)
  117  2448 		mul	r1,	r1,	r2
  118  2452 		add	r11,	r11,	r1
  119  2456 
  120  2456 
  121  2456 		%SET ARRAY INDEX: x
  122  2456 		addi	r1,	r0,	4
  123  2460 		lw	r2,	F_P_V_x_8(r0)
  124  2464 		mul	r1,	r1,	r2
  125  2468 		add	r11,	r11,	r1
  126  2472 
  127  2472 
  128  2472 
  129  2472 		subi	r14,	r14,	4	% PUSH r15
  130  2476 		sw	topaddr(r14),	r15
  131  2480 
  132  2480 
  133  2480 		subi	r14,	r14,	4	% PUSH r11
  134  2484 		sw	topaddr(r14),	r11
  135  2488 
  136  2488 		jl	r15,	getint
  137  2492 
  138  2492 		lw	r11,	topaddr(r14)	%	POP r11
  139  2496 		addi	r14,	r14,	4
  140  2500 
  141  2500 		sw	F_P_V_f1_7(r11),	r1
  142  2504 
  143  2504 		lw	r15,	topaddr(r14)	%	POP r15
  144  2508 		addi	r14,	r14,	4
  145  2512 
  146  2512 
  147  2512 		add	r11,	r0,	r0	% RESET OFFSET
  148  2516 
  149  2516 		addi	r11,	r11,	0	% Class Variable Offset 0
  150  2520 
  151  2520 		subi	r14,	r14,	4	% PUSH r11
  152  2524 		sw	topaddr(r14),	r11
  153  2528 
  154  2528 
  155  2528 		add	r11,	r0,	r0	% RESET OFFSET
  156  2532 
  157  2532 
  158  2532 		lw	r11,	topaddr(r14)	%	POP r11
  159  2536 		addi	r14,	r14,	4
  160  2540 
  161  2540 
  162  2540 		subi	r14,	r14,	4	% PUSH r11
  163  2544 		sw	topaddr(r14),	r11
  164  2548 
  165  2548 
  166  2548 		add	r11,	r0,	r0	% RESET OFFSET
  167  2552 
  168  2552 
  169  2552 		lw	r11,	topaddr(r14)	%	POP r11
  170  2556 		addi	r14,	r14,	4
  171  2560 
  172  2560 		%SET ARRAY INDEX: y
  173  2560 		addi	r1,	r0,	20
  174  2564 		lw	r2,	F_P_V_y_9(r0)
  175  2568 		mul	r1,	r1,	r2
  176  2572 		add	r11,	r11,	r1
  177  2576 
  178  2576 
  179  2576 		%SET ARRAY INDEX: y
  180  2576 		addi	r1,	r0,	4
  181  2580 		lw	r2,	F_P_V_y_9(r0)
  182  2584 		mul	r1,	r1,	r2
  183  2588 		add	r11,	r11,	r1
  184  2592 
  185  2592 
  186  2592 
  187  2592 		subi	r14,	r14,	4	% PUSH r15
  188  2596 		sw	topaddr(r14),	r15
  189  2600 
  190  2600 
  191  2600 		subi	r14,	r14,	4	% PUSH r11
  192  2604 		sw	topaddr(r14),	r11
  193  2608 
  194  2608 		jl	r15,	getint
  195  2612 
  196  2612 		lw	r11,	topaddr(r14)	%	POP r11
  197  2616 		addi	r14,	r14,	4
  198  2620 
  199  2620 		sw	F_P_V_f1_7(r11),	r1
  200  2624 
  201  2624 		lw	r15,	topaddr(r14)	%	POP r15
  202  2628 		addi	r14,	r14,	4
  203  2632 
  204  2632 
  205  2632 		add	r11,	r0,	r0	% RESET OFFSET
  206  2636 
  207  2636 		addi	r11,	r11,	0	% Class Variable Offset 0
  208  2640 
  209  2640 		subi	r14,	r14,	4	% PUSH r11
  210  2644 		sw	topaddr(r14),	r11
  211  2648 
  212  2648 
  213  2648 		add	r11,	r0,	r0	% RESET OFFSET
  214  2652 
  215  2652 
  216  2652 		add	r11,	r0,	r0	% RESET OFFSET
  217  2656 
  218  2656 		lw	r2,	F_P_V_y_9(r0)		%x+y
  219  2660 		lw	r1,	F_P_V_x_8(r0)		%
  220  2664 		add	r3,	r1,	r2
  221  2668 		sw	E_6(r0),	r3
  222  2672 
  223  2672 		lw	r11,	topaddr(r14)	%	POP r11
  224  2676 		addi	r14,	r14,	4
  225  2680 
  226  2680 
  227  2680 		subi	r14,	r14,	4	% PUSH r11
  228  2684 		sw	topaddr(r14),	r11
  229  2688 
  230  2688 
  231  2688 		add	r11,	r0,	r0	% RESET OFFSET
  232  2692 
  233  2692 
  234  2692 		add	r11,	r0,	r0	% RESET OFFSET
  235  2696 
  236  2696 		lw	r2,	F_P_V_y_9(r0)		%x+y
  237  2700 		lw	r1,	F_P_V_x_8(r0)		%
  238  2704 		add	r3,	r1,	r2
  239  2708 		sw	E_7(r0),	r3
  240  2712 
  241  2712 		lw	r11,	topaddr(r14)	%	POP r11
  242  2716 		addi	r14,	r14,	4
  243  2720 
  244  2720 		%SET ARRAY INDEX: x
  245  2720 		addi	r1,	r0,	20
  246  2724 		lw	r2,	E_6(r0)
  247  2728 		mul	r1,	r1,	r2
  248  2732 		add	r11,	r11,	r1
  249  2736 
  250  2736 
  251  2736 		%SET ARRAY INDEX: x
  252  2736 		addi	r1,	r0,	4
  253  2740 		lw	r2,	E_7(r0)
  254  2744 		mul	r1,	r1,	r2
  255  2748 		add	r11,	r11,	r1
  256  2752 
  257  2752 
  258  2752 
  259  2752 		subi	r14,	r14,	4	% PUSH r11
  260  2756 		sw	topaddr(r14),	r11
  261  2760 
  262  2760 
  263  2760 		add	r11,	r0,	r0	% RESET OFFSET
  264  2764 
  265  2764 		addi	r11,	r11,	0	% Class Variable Offset 0
  266  2768 
  267  2768 		subi	r14,	r14,	4	% PUSH r11
  268  2772 		sw	topaddr(r14),	r11
  269  2776 
  270  2776 
  271  2776 		lw	r11,	topaddr(r14)	%	POP r11
  272  2780 		addi	r14,	r14,	4
  273  2784 
  274  2784 
  275  2784 		subi	r14,	r14,	4	% PUSH r11
  276  2788 		sw	topaddr(r14),	r11
  277  2792 
  278  2792 
  279  2792 		lw	r11,	topaddr(r14)	%	POP r11
  280  2796 		addi	r14,	r14,	4
  281  2800 
  282  2800 		%SET ARRAY INDEX: 1
  283  2800 		addi	r1,	r0,	20
  284  2804 		lw	r2,	V_8(r0)
  285  2808 		mul	r1,	r1,	r2
  286  2812 		add	r11,	r11,	r1
  287  2816 
  288  2816 
  289  2816 		%SET ARRAY INDEX: 1
  290  2816 		addi	r1,	r0,	4
  291  2820 		lw	r2,	V_9(r0)
  292  2824 		mul	r1,	r1,	r2
  293  2828 		add	r11,	r11,	r1
  294  2832 
  295  2832 
  296  2832 
  297  2832 		subi	r14,	r14,	4	% PUSH r11
  298  2836 		sw	topaddr(r14),	r11
  299  2840 
  300  2840 
  301  2840 		add	r11,	r0,	r0	% RESET OFFSET
  302  2844 
  303  2844 		addi	r11,	r11,	0	% Class Variable Offset 0
  304  2848 
  305  2848 		subi	r14,	r14,	4	% PUSH r11
  306  2852 		sw	topaddr(r14),	r11
  307  2856 
  308  2856 
  309  2856 		lw	r11,	topaddr(r14)	%	POP r11
  310  2860 		addi	r14,	r14,	4
  311  2864 
  312  2864 
  313  2864 		subi	r14,	r14,	4	% PUSH r11
  314  2868 		sw	topaddr(r14),	r11
  315  2872 
  316  2872 
  317  2872 		lw	r11,	topaddr(r14)	%	POP r11
  318  2876 		addi	r14,	r14,	4
  319  2880 
  320  2880 		%SET ARRAY INDEX: 2
  321  2880 		addi	r1,	r0,	20
  322  2884 		lw	r2,	V_10(r0)
  323  2888 		mul	r1,	r1,	r2
  324  2892 		add	r11,	r11,	r1
  325  2896 
  326  2896 
  327  2896 		%SET ARRAY INDEX: 2
  328  2896 		addi	r1,	r0,	4
  329  2900 		lw	r2,	V_11(r0)
  330  2904 		mul	r1,	r1,	r2
  331  2908 		add	r11,	r11,	r1
  332  2912 
  333  2912 
  334  2912 		lw	r2,	F_P_V_f1_7(r11)		%a+a
  335  2916 
  336  2916 		lw	r11,	topaddr(r14)	%	POP r11
  337  2920 		addi	r14,	r14,	4
  338  2924 
  339  2924 		lw	r1,	F_P_V_f1_7(r11)		%
  340  2928 		add	r3,	r1,	r2
  341  2932 		sw	E_12(r0),	r3
  342  2936 		lw	r1,	E_12(r0)		%a = a
  343  2940 
  344  2940 		lw	r11,	topaddr(r14)	%	POP r11
  345  2944 		addi	r14,	r14,	4
  346  2948 
  347  2948 		sw	F_P_V_f1_7(r11),	r1
  348  2952 
  349  2952 		add	r11,	r0,	r0	% RESET OFFSET
  350  2956 
  351  2956 		addi	r11,	r11,	0	% Class Variable Offset 0
  352  2960 
  353  2960 		subi	r14,	r14,	4	% PUSH r11
  354  2964 		sw	topaddr(r14),	r11
  355  2968 
  356  2968 
  357  2968 		add	r11,	r0,	r0	% RESET OFFSET
  358  2972 
  359  2972 
  360  2972 		add	r11,	r0,	r0	% RESET OFFSET
  361  2976 
  362  2976 		lw	r2,	F_P_V_y_9(r0)		%x+y
  363  2980 		lw	r1,	F_P_V_x_8(r0)		%
  364  2984 		add	r3,	r1,	r2
  365  2988 		sw	E_13(r0),	r3
  366  2992 
  367  2992 		lw	r11,	topaddr(r14)	%	POP r11
  368  2996 		addi	r14,	r14,	4
  369  3000 
  370  3000 
  371  3000 		subi	r14,	r14,	4	% PUSH r11
  372  3004 		sw	topaddr(r14),	r11
  373  3008 
  374  3008 
  375  3008 		add	r11,	r0,	r0	% RESET OFFSET
  376  3012 
  377  3012 
  378  3012 		add	r11,	r0,	r0	% RESET OFFSET
  379  3016 
  380  3016 		lw	r2,	F_P_V_y_9(r0)		%x+y
  381  3020 		lw	r1,	F_P_V_x_8(r0)		%
  382  3024 		add	r3,	r1,	r2
  383  3028 		sw	E_14(r0),	r3
  384  3032 
  385  3032 		lw	r11,	topaddr(r14)	%	POP r11
  386  3036 		addi	r14,	r14,	4
  387  3040 
  388  3040 		%SET ARRAY INDEX: x
  389  3040 		addi	r1,	r0,	20
  390  3044 		lw	r2,	E_13(r0)
  391  3048 		mul	r1,	r1,	r2
  392  3052 		add	r11,	r11,	r1
  393  3056 
  394  3056 
  395  3056 		%SET ARRAY INDEX: x
  396  3056 		addi	r1,	r0,	4
  397  3060 		lw	r2,	E_14(r0)
  398  3064 		mul	r1,	r1,	r2
  399  3068 		add	r11,	r11,	r1
  400  3072 
  401  3072 
  402  3072 
  403  3072 		subi	r14,	r14,	4	% PUSH r15
  404  3076 		sw	topaddr(r14),	r15
  405  3080 
  406  3080 		lw	r1,	F_P_V_f1_7(r11)		% PUT  a
  407  3084 		jl	r15,	putint
  408  3088 		addi	r1,r0,13
  409  3092 		putc	r1
  410  3096 		addi	r1,r0,10
  411  3100 		putc	r1
  412  3104 
  413  3104 		lw	r15,	topaddr(r14)	%	POP r15
  414  3108 		addi	r14,	r14,	4
  415  3112 
  416  3112 
  417  3112 		add	r11,	r0,	r0	% RESET OFFSET
  418  3116 
  419  3116 
  420  3116 		add	r11,	r0,	r0	% RESET OFFSET
  421  3120 
  422  3120 		lw	r2,	F_P_V_y_9(r0)		%x+y
  423  3124 		lw	r1,	F_P_V_x_8(r0)		%
  424  3128 		add	r3,	r1,	r2
  425  3132 		sw	E_15(r0),	r3
  426  3136 
  427  3136 		add	r11,	r0,	r0	% RESET OFFSET
  428  3140 
  429  3140 
  430  3140 		add	r11,	r0,	r0	% RESET OFFSET
  431  3144 
  432  3144 		lw	r2,	F_P_V_i5_10(r0)		%j10/i5
  433  3148 		lw	r1,	F_P_V_j10_11(r0)		%
  434  3152 		div	r3,	r1,	r2
  435  3156 		sw	E_16(r0),	r3
  436  3160 		lw	r2,	E_16(r0)		%x*j10
  437  3164 		lw	r1,	E_15(r0)		%
  438  3168 		mul	r3,	r1,	r2
  439  3172 		sw	E_17(r0),	r3
  440  3176 
  441  3176 		add	r11,	r0,	r0	% RESET OFFSET
  442  3180 
  443  3180 
  444  3180 		add	r11,	r0,	r0	% RESET OFFSET
  445  3184 
  446  3184 		lw	r2,	F_P_V_x_8(r0)		%j10-x
  447  3188 		lw	r1,	F_P_V_j10_11(r0)		%
  448  3192 		sub	r3,	r1,	r2
  449  3196 		sw	E_18(r0),	r3
  450  3200 
  451  3200 		add	r11,	r0,	r0	% RESET OFFSET
  452  3204 
  453  3204 
  454  3204 		add	r11,	r0,	r0	% RESET OFFSET
  455  3208 
  456  3208 		lw	r2,	F_P_V_y_9(r0)		%i5-y
  457  3212 		lw	r1,	F_P_V_i5_10(r0)		%
  458  3216 		sub	r3,	r1,	r2
  459  3220 		sw	E_19(r0),	r3
  460  3224 		lw	r2,	E_19(r0)		%j10*i5
  461  3228 		lw	r1,	E_18(r0)		%
  462  3232 		mul	r3,	r1,	r2
  463  3236 		sw	E_20(r0),	r3
  464  3240 		lw	r2,	E_20(r0)		%x+j10
  465  3244 		lw	r1,	E_17(r0)		%
  466  3248 		add	r3,	r1,	r2
  467  3252 		sw	E_21(r0),	r3
  468  3256 
  469  3256 		subi	r14,	r14,	4	% PUSH r15
  470  3260 		sw	topaddr(r14),	r15
  471  3264 
  472  3264 		lw	r1,	E_21(r0)		% PUT  x
  473  3268 		jl	r15,	putint
  474  3272 		addi	r1,r0,13
  475  3276 		putc	r1
  476  3280 		addi	r1,r0,10
  477  3284 		putc	r1
  478  3288 
  479  3288 		lw	r15,	topaddr(r14)	%	POP r15
  480  3292 		addi	r14,	r14,	4
  481  3296 
  482  3296 
  483  3296 		add	r11,	r0,	r0	% RESET OFFSET
  484  3300 
  485  3300 
  486  3300 		add	r11,	r0,	r0	% RESET OFFSET
  487  3304 
  488  3304 
  489  3304 		add	r11,	r0,	r0	% RESET OFFSET
  490  3308 
  491  3308 		lw	r2,	F_P_V_y_9(r0)		%x+y
  492  3312 		lw	r1,	F_P_V_x_8(r0)		%
  493  3316 		add	r3,	r1,	r2
  494  3320 		sw	E_22(r0),	r3
  495  3324 
  496  3324 		add	r11,	r0,	r0	% RESET OFFSET
  497  3328 
  498  3328 
  499  3328 		add	r11,	r0,	r0	% RESET OFFSET
  500  3332 
  501  3332 		lw	r2,	F_P_V_i5_10(r0)		%j10/i5
  502  3336 		lw	r1,	F_P_V_j10_11(r0)		%
  503  3340 		div	r3,	r1,	r2
  504  3344 		sw	E_23(r0),	r3
  505  3348 		lw	r2,	E_23(r0)		%x*j10
  506  3352 		lw	r1,	E_22(r0)		%
  507  3356 		mul	r3,	r1,	r2
  508  3360 		sw	E_24(r0),	r3
  509  3364 
  510  3364 		add	r11,	r0,	r0	% RESET OFFSET
  511  3368 
  512  3368 
  513  3368 		add	r11,	r0,	r0	% RESET OFFSET
  514  3372 
  515  3372 		lw	r2,	F_P_V_x_8(r0)		%j10-x
  516  3376 		lw	r1,	F_P_V_j10_11(r0)		%
  517  3380 		sub	r3,	r1,	r2
  518  3384 		sw	E_25(r0),	r3
  519  3388 
  520  3388 		add	r11,	r0,	r0	% RESET OFFSET
  521  3392 
  522  3392 
  523  3392 		add	r11,	r0,	r0	% RESET OFFSET
  524  3396 
  525  3396 		lw	r2,	F_P_V_y_9(r0)		%i5-y
  526  3400 		lw	r1,	F_P_V_i5_10(r0)		%
  527  3404 		sub	r3,	r1,	r2
  528  3408 		sw	E_26(r0),	r3
  529  3412 		lw	r2,	E_26(r0)		%j10*i5
  530  3416 		lw	r1,	E_25(r0)		%
  531  3420 		mul	r3,	r1,	r2
  532  3424 		sw	E_27(r0),	r3
  533  3428 		lw	r2,	E_27(r0)		%x+j10
  534  3432 		lw	r1,	E_24(r0)		%
  535  3436 		add	r3,	r1,	r2
  536  3440 		sw	E_28(r0),	r3
  537  3444 		lw	r1,	E_28(r0)		%ind = x
  538  3448 		sw	F_P_V_ind_12(r0),	r1
  539  3452 
  540  3452 		add	r11,	r0,	r0	% RESET OFFSET
  541  3456 
  542  3456 
  543  3456 		subi	r14,	r14,	4	% PUSH r15
  544  3460 		sw	topaddr(r14),	r15
  545  3464 
  546  3464 		lw	r1,	F_P_V_ind_12(r0)		% PUT  ind
  547  3468 		jl	r15,	putint
  548  3472 		addi	r1,r0,13
  549  3476 		putc	r1
  550  3480 		addi	r1,r0,10
  551  3484 		putc	r1
  552  3488 
  553  3488 		lw	r15,	topaddr(r14)	%	POP r15
  554  3492 		addi	r14,	r14,	4
  555  3496 
  556  3496 
  557  3496 		add	r11,	r0,	r0	% RESET OFFSET
  558  3500 
  559  3500 		addi	r11,	r11,	100	% Class Variable Offset 100
  560  3504 
  561  3504 		subi	r14,	r14,	4	% PUSH r11
  562  3508 		sw	topaddr(r14),	r11
  563  3512 
  564  3512 
  565  3512 		add	r11,	r0,	r0	% RESET OFFSET
  566  3516 
  567  3516 
  568  3516 		lw	r11,	topaddr(r14)	%	POP r11
  569  3520 		addi	r14,	r14,	4
  570  3524 
  571  3524 		%SET ARRAY INDEX: ind
  572  3524 		addi	r1,	r0,	4
  573  3528 		lw	r2,	F_P_V_ind_12(r0)
  574  3532 		mul	r1,	r1,	r2
  575  3536 		add	r11,	r11,	r1
  576  3540 
  577  3540 
  578  3540 
  579  3540 		subi	r14,	r14,	4	% PUSH r11
  580  3544 		sw	topaddr(r14),	r11
  581  3548 
  582  3548 
  583  3548 		add	r11,	r0,	r0	% RESET OFFSET
  584  3552 
  585  3552 		lw	r1,	F_P_V_ind_12(r0)		%iE = ind
  586  3556 
  587  3556 		lw	r11,	topaddr(r14)	%	POP r11
  588  3560 		addi	r14,	r14,	4
  589  3564 
  590  3564 		sw	F_P_V_f1_7(r11),	r1
  591  3568 
  592  3568 		add	r11,	r0,	r0	% RESET OFFSET
  593  3572 
  594  3572 		addi	r11,	r11,	100	% Class Variable Offset 100
  595  3576 
  596  3576 		subi	r14,	r14,	4	% PUSH r11
  597  3580 		sw	topaddr(r14),	r11
  598  3584 
  599  3584 
  600  3584 		add	r11,	r0,	r0	% RESET OFFSET
  601  3588 
  602  3588 
  603  3588 		lw	r11,	topaddr(r14)	%	POP r11
  604  3592 		addi	r14,	r14,	4
  605  3596 
  606  3596 		%SET ARRAY INDEX: ind
  607  3596 		addi	r1,	r0,	4
  608  3600 		lw	r2,	F_P_V_ind_12(r0)
  609  3604 		mul	r1,	r1,	r2
  610  3608 		add	r11,	r11,	r1
  611  3612 
  612  3612 
  613  3612 
  614  3612 		subi	r14,	r14,	4	% PUSH r15
  615  3616 		sw	topaddr(r14),	r15
  616  3620 
  617  3620 		lw	r1,	F_P_V_f1_7(r11)		% PUT  iE
  618  3624 		jl	r15,	putint
  619  3628 		addi	r1,r0,13
  620  3632 		putc	r1
  621  3636 		addi	r1,r0,10
  622  3640 		putc	r1
  623  3644 
  624  3644 		lw	r15,	topaddr(r14)	%	POP r15
  625  3648 		addi	r14,	r14,	4
  626  3652 
  627  3652 
  628  3652 		add	r11,	r0,	r0	% RESET OFFSET
  629  3656 
  630  3656 		addi	r11,	r11,	100	% Class Variable Offset 100
  631  3660 
  632  3660 		subi	r14,	r14,	4	% PUSH r11
  633  3664 		sw	topaddr(r14),	r11
  634  3668 
  635  3668 
  636  3668 		add	r11,	r0,	r0	% RESET OFFSET
  637  3672 
  638  3672 
  639  3672 		add	r11,	r0,	r0	% RESET OFFSET
  640  3676 
  641  3676 		lw	r2,	F_P_V_y_9(r0)		%x+y
  642  3680 		lw	r1,	F_P_V_x_8(r0)		%
  643  3684 		add	r3,	r1,	r2
  644  3688 		sw	E_29(r0),	r3
  645  3692 
  646  3692 		add	r11,	r0,	r0	% RESET OFFSET
  647  3696 
  648  3696 
  649  3696 		add	r11,	r0,	r0	% RESET OFFSET
  650  3700 
  651  3700 		lw	r2,	F_P_V_i5_10(r0)		%j10/i5
  652  3704 		lw	r1,	F_P_V_j10_11(r0)		%
  653  3708 		div	r3,	r1,	r2
  654  3712 		sw	E_30(r0),	r3
  655  3716 		lw	r2,	E_30(r0)		%x*j10
  656  3720 		lw	r1,	E_29(r0)		%
  657  3724 		mul	r3,	r1,	r2
  658  3728 		sw	E_31(r0),	r3
  659  3732 
  660  3732 		add	r11,	r0,	r0	% RESET OFFSET
  661  3736 
  662  3736 
  663  3736 		add	r11,	r0,	r0	% RESET OFFSET
  664  3740 
  665  3740 		lw	r2,	F_P_V_x_8(r0)		%j10-x
  666  3744 		lw	r1,	F_P_V_j10_11(r0)		%
  667  3748 		sub	r3,	r1,	r2
  668  3752 		sw	E_32(r0),	r3
  669  3756 
  670  3756 		add	r11,	r0,	r0	% RESET OFFSET
  671  3760 
  672  3760 
  673  3760 		add	r11,	r0,	r0	% RESET OFFSET
  674  3764 
  675  3764 		lw	r2,	F_P_V_y_9(r0)		%i5-y
  676  3768 		lw	r1,	F_P_V_i5_10(r0)		%
  677  3772 		sub	r3,	r1,	r2
  678  3776 		sw	E_33(r0),	r3
  679  3780 		lw	r2,	E_33(r0)		%j10*i5
  680  3784 		lw	r1,	E_32(r0)		%
  681  3788 		mul	r3,	r1,	r2
  682  3792 		sw	E_34(r0),	r3
  683  3796 		lw	r2,	E_34(r0)		%x+j10
  684  3800 		lw	r1,	E_31(r0)		%
  685  3804 		add	r3,	r1,	r2
  686  3808 		sw	E_35(r0),	r3
  687  3812 
  688  3812 		lw	r11,	topaddr(r14)	%	POP r11
  689  3816 		addi	r14,	r14,	4
  690  3820 
  691  3820 		%SET ARRAY INDEX: x
  692  3820 		addi	r1,	r0,	4
  693  3824 		lw	r2,	E_35(r0)
  694  3828 		mul	r1,	r1,	r2
  695  3832 		add	r11,	r11,	r1
  696  3836 
  697  3836 
  698  3836 
  699  3836 		subi	r14,	r14,	4	% PUSH r11
  700  3840 		sw	topaddr(r14),	r11
  701  3844 
  702  3844 
  703  3844 		add	r11,	r0,	r0	% RESET OFFSET
  704  3848 
  705  3848 
  706  3848 		add	r11,	r0,	r0	% RESET OFFSET
  707  3852 
  708  3852 		lw	r2,	F_P_V_y_9(r0)		%x+y
  709  3856 		lw	r1,	F_P_V_x_8(r0)		%
  710  3860 		add	r3,	r1,	r2
  711  3864 		sw	E_36(r0),	r3
  712  3868 
  713  3868 		add	r11,	r0,	r0	% RESET OFFSET
  714  3872 
  715  3872 
  716  3872 		add	r11,	r0,	r0	% RESET OFFSET
  717  3876 
  718  3876 		lw	r2,	F_P_V_i5_10(r0)		%j10/i5
  719  3880 		lw	r1,	F_P_V_j10_11(r0)		%
  720  3884 		div	r3,	r1,	r2
  721  3888 		sw	E_37(r0),	r3
  722  3892 		lw	r2,	E_37(r0)		%x*j10
  723  3896 		lw	r1,	E_36(r0)		%
  724  3900 		mul	r3,	r1,	r2
  725  3904 		sw	E_38(r0),	r3
  726  3908 
  727  3908 		add	r11,	r0,	r0	% RESET OFFSET
  728  3912 
  729  3912 
  730  3912 		add	r11,	r0,	r0	% RESET OFFSET
  731  3916 
  732  3916 		lw	r2,	F_P_V_x_8(r0)		%j10-x
  733  3920 		lw	r1,	F_P_V_j10_11(r0)		%
  734  3924 		sub	r3,	r1,	r2
  735  3928 		sw	E_39(r0),	r3
  736  3932 
  737  3932 		add	r11,	r0,	r0	% RESET OFFSET
  738  3936 
  739  3936 
  740  3936 		add	r11,	r0,	r0	% RESET OFFSET
  741  3940 
  742  3940 		lw	r2,	F_P_V_y_9(r0)		%i5-y
  743  3944 		lw	r1,	F_P_V_i5_10(r0)		%
  744  3948 		sub	r3,	r1,	r2
  745  3952 		sw	E_40(r0),	r3
  746  3956 		lw	r2,	E_40(r0)		%j10*i5
  747  3960 		lw	r1,	E_39(r0)		%
  748  3964 		mul	r3,	r1,	r2
  749  3968 		sw	E_41(r0),	r3
  750  3972 		lw	r2,	E_41(r0)		%x+j10
  751  3976 		lw	r1,	E_38(r0)		%
  752  3980 		add	r3,	r1,	r2
  753  3984 		sw	E_42(r0),	r3
  754  3988 		lw	r1,	E_42(r0)		%iE = x
  755  3992 
  756  3992 		lw	r11,	topaddr(r14)	%	POP r11
  757  3996 		addi	r14,	r14,	4
  758  4000 
  759  4000 		sw	F_P_V_f1_7(r11),	r1
  760  4004 
  761  4004 		add	r11,	r0,	r0	% RESET OFFSET
  762  4008 
  763  4008 		addi	r11,	r11,	100	% Class Variable Offset 100
  764  4012 
  765  4012 		subi	r14,	r14,	4	% PUSH r11
  766  4016 		sw	topaddr(r14),	r11
  767  4020 
  768  4020 
  769  4020 		add	r11,	r0,	r0	% RESET OFFSET
  770  4024 
  771  4024 
  772  4024 		add	r11,	r0,	r0	% RESET OFFSET
  773  4028 
  774  4028 		lw	r2,	F_P_V_y_9(r0)		%x+y
  775  4032 		lw	r1,	F_P_V_x_8(r0)		%
  776  4036 		add	r3,	r1,	r2
  777  4040 		sw	E_43(r0),	r3
  778  4044 
  779  4044 		add	r11,	r0,	r0	% RESET OFFSET
  780  4048 
  781  4048 
  782  4048 		add	r11,	r0,	r0	% RESET OFFSET
  783  4052 
  784  4052 		lw	r2,	F_P_V_i5_10(r0)		%j10/i5
  785  4056 		lw	r1,	F_P_V_j10_11(r0)		%
  786  4060 		div	r3,	r1,	r2
  787  4064 		sw	E_44(r0),	r3
  788  4068 		lw	r2,	E_44(r0)		%x*j10
  789  4072 		lw	r1,	E_43(r0)		%
  790  4076 		mul	r3,	r1,	r2
  791  4080 		sw	E_45(r0),	r3
  792  4084 
  793  4084 		add	r11,	r0,	r0	% RESET OFFSET
  794  4088 
  795  4088 
  796  4088 		add	r11,	r0,	r0	% RESET OFFSET
  797  4092 
  798  4092 		lw	r2,	F_P_V_x_8(r0)		%j10-x
  799  4096 		lw	r1,	F_P_V_j10_11(r0)		%
  800  4100 		sub	r3,	r1,	r2
  801  4104 		sw	E_46(r0),	r3
  802  4108 
  803  4108 		add	r11,	r0,	r0	% RESET OFFSET
  804  4112 
  805  4112 
  806  4112 		add	r11,	r0,	r0	% RESET OFFSET
  807  4116 
  808  4116 		lw	r2,	F_P_V_y_9(r0)		%i5-y
  809  4120 		lw	r1,	F_P_V_i5_10(r0)		%
  810  4124 		sub	r3,	r1,	r2
  811  4128 		sw	E_47(r0),	r3
  812  4132 		lw	r2,	E_47(r0)		%j10*i5
  813  4136 		lw	r1,	E_46(r0)		%
  814  4140 		mul	r3,	r1,	r2
  815  4144 		sw	E_48(r0),	r3
  816  4148 		lw	r2,	E_48(r0)		%x+j10
  817  4152 		lw	r1,	E_45(r0)		%
  818  4156 		add	r3,	r1,	r2
  819  4160 		sw	E_49(r0),	r3
  820  4164 
  821  4164 		lw	r11,	topaddr(r14)	%	POP r11
  822  4168 		addi	r14,	r14,	4
  823  4172 
  824  4172 		%SET ARRAY INDEX: x
  825  4172 		addi	r1,	r0,	4
  826  4176 		lw	r2,	E_49(r0)
  827  4180 		mul	r1,	r1,	r2
  828  4184 		add	r11,	r11,	r1
  829  4188 
  830  4188 
  831  4188 
  832  4188 		subi	r14,	r14,	4	% PUSH r15
  833  4192 		sw	topaddr(r14),	r15
  834  4196 
  835  4196 		lw	r1,	F_P_V_f1_7(r11)		% PUT  iE
  836  4200 		jl	r15,	putint
  837  4204 		addi	r1,r0,13
  838  4208 		putc	r1
  839  4212 		addi	r1,r0,10
  840  4216 		putc	r1
  841  4220 
  842  4220 		lw	r15,	topaddr(r14)	%	POP r15
  843  4224 		addi	r14,	r14,	4
  844  4228 
  845  4228 		hlt

MOON listing of util.m.

    1  4232 %==============================================================%
    2  4232 % File:        util.m                                          %
    3  4232 % Author:      Nagi B. F. MIKHAIL                              %
    4  4232 % Date:        April, 1995                                     %
    5  4232 % Description: This file contains utility routines written in  %
    6  4232 %              MOON's assembly to handle string operations &   %
    7  4232 %              Input/Output.                                   %
    8  4232 %==============================================================%
    9  4232 %
   10  4232 %
   11  4232 %--------------------------------------------------------------%
   12  4232 % getint                                                       %
   13  4232 %--------------------------------------------------------------%
   14  4232 % Read an integer number from stdin. Read until a non digit char
   15  4232 % is entered. Allowes (+) & (-) signs only as first char. The
   16  4232 % digits are read in ASCII and transformed to numbers.
   17  4232 % Entry : none.
   18  4232 % Exit : result -> r1
   19  4232 %
   20  4232 getint	align
   21  4232 	add	r1,r0,r0		% Initialize input register (r1 = 0)
   22  4236 	add	r2,r0,r0		% Initialize buffer's index i
   23  4240 	add	r4,r0,r0		% Initialize sign flag
   24  4244 getint1	getc	r1			% Input ch
   25  4248 	ceqi	r3,r1,43		% ch = '+' ?
   26  4252 	bnz	r3,getint1		% Branch if true (ch = '+')
   27  4256 	ceqi	r3,r1,45		% ch = '-' ?
   28  4260 	bz	r3,getint2		% Branch if false (ch != '-')
   29  4264 	addi	r4,r0,1			% Set sign flag to true
   30  4268 	j	getint1			% Loop to get next ch
   31  4272 getint2	clti	r3,r1,48		% ch < '0' ?
   32  4276 	bnz	r3,getint3		% Branch if true (ch < '0')
   33  4280 	cgti	r3,r1,57		% ch > '9' ?
   34  4284 	bnz	r3,getint3		% Branch if true (ch > '9')
   35  4288 	sb	getint9(r2),r1		% Store ch in buffer
   36  4292 	addi	r2,r2,1			% i++
   37  4296 	j	getint1			% Loop if not finished
   38  4300 getint3	sb	getint9(r2),r0		% Store end of string in buffer (ch = '\0')
   39  4304 	add	r2,r0,r0		% i = 0
   40  4308 	add	r1,r0,r0		% N = 0
   41  4312 	add	r3,r0,r0		% Initialize r3
   42  4316 getint4	lb	r3,getint9(r2)		% Load ch from buffer
   43  4320 	bz	r3,getint5		% Branch if end of string (ch = '\0')
   44  4324 	subi	r3,r3,48		% Convert to number (M)
   45  4328 	muli	r1,r1,10		% N *= 10
   46  4332 	add	r1,r1,r3		% N += M
   47  4336 	addi	r2,r2,1			% i++
   48  4340 	j	getint4			% Loop if not finished
   49  4344 getint5	bz	r4,getint6		% Branch if sign flag false
   50  4348 	sub	r1,r0,r1		% N = -N
   51  4352 getint6	jr	r15			% Return to the caller
   52  4356 getint9	res	12			% Local buffer (12 bytes)
   53  4368 	align
   54  4368 %
   55  4368 %
   56  4368 %--------------------------------------------------------------%
   57  4368 % putint                                                       %
   58  4368 %--------------------------------------------------------------%
   59  4368 % Write an integer number to stdout. Transform the number into
   60  4368 % ASCII string taking the sign into account.
   61  4368 % Entry : integer number -> r1
   62  4368 % Exit : none.
   63  4368 %
   64  4368 putint	align
   65  4368 	add	r2,r0,r0		% Initialize buffer's index i
   66  4372 	cge	r3,r1,r0		% True if N >= 0
   67  4376 	bnz	r3,putint1		% Branch if True (N >= 0)
   68  4380 	sub	r1,r0,r1		% N = -N
   69  4384 putint1	modi	r4,r1,10		% Rightmost digit
   70  4388 	addi	r4,r4,48		% Convert to ch
   71  4392 	divi	r1,r1,10		% Truncate rightmost digit
   72  4396 	sb	putint9(r2),r4		% Store ch in buffer
   73  4400 	addi	r2,r2,1			% i++
   74  4404 	bnz	r1,putint1		% Loop if not finished
   75  4408 	bnz	r3,putint2		% Branch if True (N >= 0)
   76  4412 	addi	r3,r0,45
   77  4416 	sb	putint9(r2),r3		% Store '-' in buffer
   78  4420 	addi	r2,r2,1			% i++
   79  4424 	add	r1,r0,r0		% Initialize output register (r1 = 0)
   80  4428 putint2	subi	r2,r2,1			% i--
   81  4432 	lb	r1,putint9(r2)		% Load ch from buffer
   82  4436 	putc	r1			% Output ch
   83  4440 	bnz	r2,putint2		% Loop if not finished
   84  4444 	jr	r15			% return to the caller
   85  4448 putint9	res	12			% loacl buffer (12 bytes)
   86  4460 	align
   87  4460 %
   88  4460 %
   89  4460 %--------------------------------------------------------------%
   90  4460 % putstr                                                       %
   91  4460 %--------------------------------------------------------------%
   92  4460 % Write a string to stdout. Write char by char until end of 
   93  4460 % string.
   94  4460 % Entry : address of string -> r1
   95  4460 % Exit : none.
   96  4460 % 
   97  4460 putstr	align
   98  4460 	add	r2,r0,r0		% Initialize output register (r2 = 0)
   99  4464 putstr1	lb	r2,0(r1)		% Load ch from buffer
  100  4468 	bz	r2,putstr2		% Branch if end of string (ch = '\0')
  101  4472 	putc	r2			% Output ch
  102  4476 	addi	r1,r1,1			% i++
  103  4480 	j	putstr1			% Loop if not finished
  104  4484 putstr2	jr	r15			% Return to the caller
  105  4488 	align
  106  4488 %
  107  4488 %
  108  4488 %--------------------------------------------------------------%
  109  4488 % putsub                                                       %
  110  4488 %--------------------------------------------------------------% 
  111  4488 % Write a substring to stdout. Write char by char until end of 
  112  4488 % substring.
  113  4488 % Entry : address of substring -> r1
  114  4488 %         address of end of substring -> r3
  115  4488 % Exit : none.
  116  4488 % 
  117  4488 putsub	align
  118  4488 	add	r2,r0,r0		% Initialize output register (r2 = 0)
  119  4492 putsub1	lb	r2,0(r1)		% Load ch from buffer
  120  4496 	putc	r2			% Output ch
  121  4500 	ceq	r2,r1,r3		% Current pos. is end of substring ?
  122  4504 	bnz	r2,putsub2		% Branch if end of substring
  123  4508 	addi	r1,r1,1			% i++
  124  4512 	j	putsub1			% Loop if not finished
  125  4516 putsub2	jr	r15			% Return to the caller
  126  4520 	align
  127  4520 %
  128  4520 %
  129  4520 %--------------------------------------------------------------%
  130  4520 % getstr                                                       %
  131  4520 %--------------------------------------------------------------%
  132  4520 % Read a string from stdin. Read char by char until CR but do 
  133  4520 % not store CR.
  134  4520 % Entry : address of string var. -> r1
  135  4520 % Exit : address of string var. -> r1
  136  4520 %
  137  4520 getstr	align
  138  4520 	add	r2,r0,r0		% Initialize input register (r2 = 0)
  139  4524 	getc	r2			% Input ch
  140  4528 	ceqi	r3,r2,10		% ch = CR ?
  141  4532 	bnz	r3,getstr1		% branch if true (ch = CR)
  142  4536 	sb	0(r1),r2		% Store ch in buffer
  143  4540 	addi	r1,r1,1			% i++
  144  4544 	j	getstr			% Loop if not finished
  145  4548 getstr1	sb	0(r1),r0		% Store end of string (ch = '\0')
  146  4552 	jr	r15			% Return to the caller
  147  4556 	align
  148  4556 %
  149  4556 %
  150  4556 %--------------------------------------------------------------%
  151  4556 % catstr                                                       %
  152  4556 %--------------------------------------------------------------%
  153  4556 % Append one string to another.
  154  4556 % Entry : address of 1st string -> r1
  155  4556 %         address of 2nd string -> r2
  156  4556 % Exit : address of concatenated strings -> r1
  157  4556 %
  158  4556 catstr	align
  159  4556 	add	r3,r0,r0		% r3 = 0
  160  4560 catstr1	lb	r3,0(r1)		% Load ch from 1st string
  161  4564 	bz	r3,catstr2		% Branch if end of string (ch = `\0')
  162  4568 	addi	r1,r1,1			% i++
  163  4572 	j	catstr1			% Loop if not end of 1st string
  164  4576 catstr2	lb	r3,0(r2)		% Load ch from 2nd string
  165  4580 	sb	0(r1),r3		% Store ch at the end of 1st string
  166  4584 	bz	r3,catstr3		% Branch if end of 2nd string
  167  4588 	addi	r2,r2,1			% j++
  168  4592 	addi	r1,r1,1			% i++
  169  4596 	j	catstr2			% Loop if not end of 2nd string
  170  4600 catstr3	jr	r15			% Return to the caller
  171  4604 	align
  172  4604 %
  173  4604 %
  174  4604 %--------------------------------------------------------------%
  175  4604 % catsub                                                       %
  176  4604 %--------------------------------------------------------------%
  177  4604 % Append a substring to a string.
  178  4604 % Entry : address of string -> r1
  179  4604 %         address of substring -> r2
  180  4604 %         address of end of substring -> r4
  181  4604 % Exit : address of concatenated strings -> r1
  182  4604 % 
  183  4604 catsub	align
  184  4604 	add	r3,r0,r0		% r3 = 0
  185  4608 catsub1	lb	r3,0(r1)		% Load ch from 1st string
  186  4612 	bz	r3,catsub2		% Branch if end of string (ch = `\0')
  187  4616 	addi	r1,r1,1			% i++
  188  4620 	j	catsub1			% Loop if not end of 1st string
  189  4624 catsub2	lb	r3,0(r2)		% Load ch from substring
  190  4628 	sb	0(r1),r3		% Store ch at the end of 1st string
  191  4632 	bz	r3,catsub4		% Branch if end of string ch
  192  4636 	addi	r1,r1,1			% i++
  193  4640 	ceq	r3,r2,r4		% Check end of substring
  194  4644 	bnz	r3,catsub3		% Branch if end of substring
  195  4648 	addi	r2,r2,1			% j++
  196  4652 	j	catsub2			% Loop if not end of substring
  197  4656 catsub3	sb	0(r1),r0		% Store end of string
  198  4660 catsub4	jr	r15			% Return to the caller
  199  4664 	align
  200  4664 %
  201  4664 %
  202  4664 %--------------------------------------------------------------%
  203  4664 % eqstr                                                        %
  204  4664 %--------------------------------------------------------------%
  205  4664 % Check if string1 = string2.
  206  4664 % Entry : address of string1 -> r1
  207  4664 %         address of string2 -> r2
  208  4664 % Exit : r1 = 1 (true)
  209  4664 %        r1 = 0 (false)
  210  4664 %
  211  4664 eqstr	align
  212  4664 	add	r3,r0,r0		% Initialize r3 (r3 = 0)
  213  4668 	add	r4,r0,r0		% Initialize r4 (r4 = 0)
  214  4672 eqstr1	lb	r3,0(r1)		% Load ch1 from 1st string
  215  4676 	lb	r4,0(r2)		% Load ch2 from 2nd string
  216  4680 	ceq	r5,r3,r4		% ch1 = ch2 ?
  217  4684 	bz	r5,eqstr2		% Branch if false
  218  4688 	ceq	r5,r3,r0		% ch1 = '\0' ?
  219  4692 	bnz	r5,eqstr3		% Branch if true
  220  4696 	addi	r1,r1,1			% i++
  221  4700 	addi	r2,r2,1			% j++
  222  4704 	j	eqstr1			% Loop if not finished
  223  4708 eqstr2	add	r1,r0,r0		% Return false
  224  4712 	j	eqstr4
  225  4716 eqstr3	addi	r1,r0,1			% Return true
  226  4720 eqstr4	jr	r15			% Return to the caller
  227  4724 	align
  228  4724 %
  229  4724 %
  230  4724 %--------------------------------------------------------------%
  231  4724 % neqstr                                                       %
  232  4724 %--------------------------------------------------------------%
  233  4724 % Check if string1 != string2.
  234  4724 % Entry : address of string1 -> r1
  235  4724 %         address of string2 -> r2
  236  4724 % Exit : r1 = 1 (true)
  237  4724 %        r1 = 0 (false)
  238  4724 % 
  239  4724 neqstr	align
  240  4724 	add	r3,r0,r0		% Initialize r3 (r3 = 0)
  241  4728 	add	r4,r0,r0		% Initialize r4 (r4 = 0)
  242  4732 neqstr1	lb	r3,0(r1)		% Load ch1 from 1st string
  243  4736 	lb	r4,0(r2)		% Load ch2 from 2nd string
  244  4740 	cne	r5,r3,r4		% ch1 != ch2 ?
  245  4744 	bnz	r5,neqstr3		% Branch if true
  246  4748 	ceq	r5,r3,r0		% ch1 = '\0' ?
  247  4752 	bnz	r5,neqstr2		% Branch if true
  248  4756 	addi	r1,r1,1			% i++
  249  4760 	addi	r2,r2,1			% j++
  250  4764 	j	neqstr1			% Loop if not finished
  251  4768 neqstr2	add	r1,r0,r0		% Return false
  252  4772 	j	neqstr4
  253  4776 neqstr3	addi	r1,r0,1			% Return true
  254  4780 neqstr4	jr	r15			% Return to the caller
  255  4784 	align
  256  4784 %
  257  4784 %
  258  4784 %--------------------------------------------------------------%
  259  4784 % gtstr                                                        %
  260  4784 %--------------------------------------------------------------%
  261  4784 % Check if string1 > string2.
  262  4784 % Entry : address of string1 -> r1
  263  4784 %         address of string2 -> r2
  264  4784 % Exit : r1 = 1 (true)
  265  4784 %        r1 = 0 (false)
  266  4784 %
  267  4784 gtstr	align
  268  4784 	add	r3,r0,r0		% Initialize r3 (r3 = 0)
  269  4788 	add	r4,r0,r0		% Initialize r4 (r4 = 0)
  270  4792 gtstr1	lb	r3,0(r1)		% Load ch1 from 1st string
  271  4796 	lb	r4,0(r2)		% Load ch2 from 2nd string
  272  4800 	cgt	r5,r3,r4		% ch1 > ch2 ?
  273  4804 	bnz	r5,gtstr3		% Branch if true
  274  4808 	clt	r5,r3,r4		% ch1 < ch2 ?
  275  4812 	bnz	r5,gtstr2		% Branch if true
  276  4816 	ceq	r5,r3,r0		% ch1 = '\0' ?
  277  4820 	bnz	r5,gtstr2		% Branch if true
  278  4824 	addi	r1,r1,1			% i++
  279  4828 	addi	r2,r2,1			% j++
  280  4832 	j	gtstr1			% Loop if not finished
  281  4836 gtstr2	add	r1,r0,r0		% Return false
  282  4840 	j	gtstr4
  283  4844 gtstr3	addi	r1,r0,1			% Return true
  284  4848 gtstr4	jr	r15			% Return to the caller
  285  4852 	align
  286  4852 %
  287  4852 %
  288  4852 %--------------------------------------------------------------%
  289  4852 % gtestr                                                       %
  290  4852 %--------------------------------------------------------------%
  291  4852 % Check if string1 >= string2.
  292  4852 % Entry : address of string1 -> r1
  293  4852 %         address of string2 -> r2
  294  4852 % Exit : r1 = 1 (true)
  295  4852 %        r1 = 0 (false)
  296  4852 %
  297  4852 gtestr	align
  298  4852 	add	r3,r0,r0		% Initialize r3 (r3 = 0)
  299  4856 	add	r4,r0,r0		% Initialize r4 (r4 = 0)
  300  4860 gtestr1	lb	r3,0(r1)		% Load ch1 from 1st string
  301  4864 	lb	r4,0(r2)		% Load ch2 from 2nd string
  302  4868 	cgt	r5,r3,r4		% ch1 > ch2 ?
  303  4872 	bnz	r5,gtestr3		% Branch if true
  304  4876 	clt	r5,r3,r4		% ch1 < ch2 ?
  305  4880 	bnz	r5,gtestr2		% Branch if true
  306  4884 	ceq	r5,r3,r0		% ch1 = '\0' ?
  307  4888 	bnz	r5,gtestr3		% Branch if true
  308  4892 	addi	r1,r1,1			% i++
  309  4896 	addi	r2,r2,1			% j++
  310  4900 	j	gtestr1			% Loop if not finished
  311  4904 gtestr2	add	r1,r0,r0		% Return false
  312  4908 	j	gtestr4
  313  4912 gtestr3	addi	r1,r0,1			% Return true
  314  4916 gtestr4	jr	r15			% Return to the caller
  315  4920 	align
  316  4920 %
  317  4920 %
  318  4920 %--------------------------------------------------------------%
  319  4920 % ltstr                                                        %
  320  4920 %--------------------------------------------------------------%
  321  4920 % Check if string1 < string2.
  322  4920 % Entry : address of string1 -> r1
  323  4920 %         address of string2 -> r2
  324  4920 % Exit : r1 = 1 (true)
  325  4920 %        r1 = 0 (false)
  326  4920 %
  327  4920 ltstr	align
  328  4920 	add	r3,r0,r0		% Initialize r3 (r3 = 0)
  329  4924 	add	r4,r0,r0		% Initialize r4 (r4 = 0)
  330  4928 ltstr1	lb	r3,0(r1)		% Load ch1 from 1st string
  331  4932 	lb	r4,0(r2)		% Load ch2 from 2nd string
  332  4936 	clt	r5,r3,r4		% ch1 < ch2 ?
  333  4940 	bnz	r5,ltstr3		% Branch if true
  334  4944 	cgt	r5,r3,r4		% ch1 > ch2 ?
  335  4948 	bnz	r5,ltstr2		% Branch if true
  336  4952 	ceq	r5,r3,r0		% ch1 = '\0' ?
  337  4956 	bnz	r5,ltstr2		% Branch if true
  338  4960 	addi	r1,r1,1			% i++
  339  4964 	addi	r2,r2,1			% j++
  340  4968 	j	ltstr1			% Loop if not finished
  341  4972 ltstr2	add	r1,r0,r0		% Return false
  342  4976 	j	ltstr4
  343  4980 ltstr3	addi	r1,r0,1			% Return true
  344  4984 ltstr4	jr	r15			% Return to the caller
  345  4988 	align
  346  4988 %
  347  4988 %
  348  4988 %--------------------------------------------------------------%
  349  4988 % ltestr                                                       %
  350  4988 %--------------------------------------------------------------%
  351  4988 % Check if string1 <= string2.
  352  4988 % Entry : address of string1 -> r1
  353  4988 %         address of string2 -> r2
  354  4988 % Exit : r1 = 1 (true)
  355  4988 %        r1 = 0 (false)
  356  4988 %
  357  4988 ltestr	align
  358  4988 	add	r3,r0,r0		% Initialize r3 (r3 = 0)
  359  4992 	add	r4,r0,r0		% Initialize r4 (r4 = 0)
  360  4996 ltestr1	lb	r3,0(r1)		% Load ch1 from 1st string
  361  5000 	lb	r4,0(r2)		% Load ch2 from 2nd string
  362  5004 	clt	r5,r3,r4		% ch1 < ch2 ?
  363  5008 	bnz	r5,ltestr3		% Branch if true
  364  5012 	cgt	r5,r3,r4		% ch1 > ch2 ?
  365  5016 	bnz	r5,ltestr2		% Branch if true
  366  5020 	ceq	r5,r3,r0		% ch1 = '\0' ?
  367  5024 	bnz	r5,ltestr3		% Branch if true
  368  5028 	addi	r1,r1,1			% i++
  369  5032 	addi	r2,r2,1			% j++
  370  5036 	j	ltestr1			% Loop if not finished
  371  5040 ltestr2	add	r1,r0,r0		% Return false
  372  5044 	j	ltestr4
  373  5048 ltestr3	addi	r1,r0,1			% Return true
  374  5052 ltestr4	jr	r15			% Return to the caller
  375  5056 	align
  376  5056 %
  377  5056 %
  378  5056 %--------------------------------------------------------------%
  379  5056 % lenstr                                                       %
  380  5056 %--------------------------------------------------------------%
  381  5056 % Returns length of string. '\n' is concidered one char.
  382  5056 % Entry : address of string -> -8(r14)
  383  5056 % Exit : result -> -12(r14)
  384  5056 %
  385  5056 lenstr	align
  386  5056 	sw	-4(r14),r15		% Store link in stack
  387  5060 	sw	-16(r14),r1		% Save registers' old values on stack
  388  5064 	sw	-20(r14),r2
  389  5068 	sw	-24(r14),r3
  390  5072 	sw	-28(r14),r4
  391  5076 	lw	r1,-8(r14)		% Retrieve argument from stack
  392  5080 	add	r2,r0,r0		% Initialize length counter (len = 0)
  393  5084 	add	r3,r0,r0		% Initialize ch holder (r3 = 0)
  394  5088 lenstr1	lb	r3,0(r1)		% Load ch from string
  395  5092 	ceq	r4,r3,r0		% ch = '\0' ?
  396  5096 	bnz	r4,lenstr2		% Branch if true
  397  5100 	addi	r1,r1,1			% i++
  398  5104 	ceqi	r4,r3,13		% ch = LF ?
  399  5108 	bnz	r4,lenstr1		% Skip ch and loop
  400  5112 	addi	r2,r2,1			% len++
  401  5116 	j	lenstr1			% Loop if not finished
  402  5120 lenstr2	add	r1,r0,r2		% Return length of the string
  403  5124 	sw	-12(r14),r1		% Save result on stack
  404  5128 	lw	r1,-16(r14)		% Reset registers to their old values
  405  5132 	lw	r2,-20(r14)
  406  5136 	lw	r3,-24(r14)
  407  5140 	lw	r4,-28(r14)
  408  5144 	lw	r15,-4(r14)		% Load link from stack
  409  5148 	jr	r15			% Return to the caller
  410  5152 	align
  411  5152 %
  412  5152 %
  413  5152 %--------------------------------------------------------------%
  414  5152 % ordstr                                                       %
  415  5152 %--------------------------------------------------------------%
  416  5152 % Returns ASCII number of the 1st char of a string.
  417  5152 % Entry : address of string -> -8(r14)
  418  5152 % Exit : result -> -12(r14)
  419  5152 %
  420  5152 ordstr	align
  421  5152 	sw	-4(r14),r15		% Store link in stack
  422  5156 	sw	-16(r14),r1		% Save registers' old values on stack
  423  5160 	sw	-20(r14),r2
  424  5164 	lw	r1,-8(r14)		% Retrieve argument from stack
  425  5168 	add	r2,r0,r0		% Initialize ch holder (r2 = 0)
  426  5172 	lb	r2,0(r1)		% Load ch from string
  427  5176 	add	r1,r0,r2		% Return ascii code of ch
  428  5180 	sw	-12(r14),r1		% Save result on stack
  429  5184 	lw	r1,-16(r14)		% Reset registers to their old values
  430  5188 	lw	r2,-20(r14)
  431  5192 	lw	r15,-4(r14)		% Load link from stack
  432  5196 	jr	r15			% Return to the caller
  433  5200 	align
  434  5200 %
  435  5200 %
  436  5200 %--------------------------------------------------------------%
  437  5200 % substr                                                       %
  438  5200 %--------------------------------------------------------------%
  439  5200 % Returns the start & end pos. of a substring. '\n' is concidered
  440  5200 % one char. Returns empty string in case of illegal start and/or
  441  5200 % substring pos.
  442  5200 % Entry : address of string -> -8(r14)
  443  5200 %         substring start pos. -> -12(r14)
  444  5200 %         substring end pos. -> -16(r14)
  445  5200 % Exit : address of substring start pos. -> -20(r14)
  446  5200 %        address of substring end pos. -> -24(r14)
  447  5200 %
  448  5200 substr	align
  449  5200 	sw	-4(r14),r15		% Store link in stack
  450  5204 	sw	-28(r14),r1		% Save registers' old values on stack
  451  5208 	sw	-32(r14),r2
  452  5212 	sw	-36(r14),r3
  453  5216 	sw	-40(r14),r4
  454  5220 	sw	-44(r14),r5
  455  5224 	sw	-48(r14),r6
  456  5228 	lw	r1,-8(r14)		% Retrieve arguments from stack
  457  5232 	lw	r2,-12(r14)
  458  5236 	lw	r3,-16(r14)
  459  5240 	add	r5,r0,r0		% Initialize copy reg (r5 = 0)
  460  5244 	cle	r4,r2,r0		% N < 0 ?
  461  5248 	bnz	r4,substr4		% Branch if true
  462  5252 	cle	r4,r2,r3		% M <= N ?
  463  5256 	bz	r4,substr4		% Branch if true
  464  5260 	add	r2,r2,r1		% Start pos. of the substr. in memory
  465  5264 	subi	r2,r2,1
  466  5268 	add	r3,r3,r1		% End pos. of substr. in memory
  467  5272 	subi	r3,r3,1
  468  5276 substr1	lb	r5,0(r1)		% Load ch in copy register starting from ch1
  469  5280 	ceq	r6,r5,r0		% ch = '\0' ?
  470  5284 	bnz	r6,substr4		% Branch if true
  471  5288 	ceq	r4,r2,r1		% Current pos. = Start pos. ?
  472  5292 	bnz	r4,substr2		% Branch if true
  473  5296 	ceqi	r6,r5,13		% ch = LF ?
  474  5300 	bz	r6,substr6		% Branch if false
  475  5304 	addi	r2,r2,1			% Move start pos
  476  5308 	addi	r3,r3,1			% Move end pos
  477  5312 substr6	addi	r1,r1,1			% Move current pos.
  478  5316 	j	substr1			% Loop if current pos. != start pos.
  479  5320 substr2	lb	r5,0(r2)		% Load ch in copy register starting from star pos.
  480  5324 	ceq	r6,r5,r0		% ch = '\0' ?
  481  5328 	bnz	r6,substr4		% Branch if true
  482  5332 	ceqi	r6,r5,13		% ch = LF ?
  483  5336 	bz	r6,substr7		% Branch if false
  484  5340 	addi	r3,r3,1			% Move end pos
  485  5344 substr7	ceq	r4,r3,r2		% Current pos. = end pos. ?
  486  5348 	bnz	r4,substr3		% Branch if true
  487  5352 	addi	r2,r2,1			% Move current pos.
  488  5356 	j	substr2			% Loop if current pos. != end pos.
  489  5360 substr3	lb	r5,0(r3)		% Load ch of end pos. in copy register
  490  5364 	ceq	r6,r5,r0		% ch = '\0' ?
  491  5368 	bnz	r6,substr4		% Branch if true
  492  5372 	j	substr5
  493  5376 substr4	addi	r1,r0,EMPTY		% Start & end pos. pointing to ""
  494  5380 	addi	r3,r0,EMPTY
  495  5384 substr5	sw	-20(r14),r1		% Store results on stack
  496  5388 	sw	-24(r14),r3
  497  5392 	lw	r1,-28(r14)		% Reset regiters to old values
  498  5396 	lw	r2,-32(r14)
  499  5400 	lw	r3,-36(r14)
  500  5404 	lw	r4,-40(r14)
  501  5408 	lw	r5,-44(r14)
  502  5412 	lw	r6,-48(r14)
  503  5416 	lw	r15,-4(r14)		% Load link from stack
  504  5420 	jr	r15			% Return to caller
  505  5424 	align
  506  5424 EMPTY	db	0			% Empty string
  507  5425 	align
  508  5428 %
  509  5428 %
  510  5428 %-------------------------  End of file -----------------------%
  511  5428 

